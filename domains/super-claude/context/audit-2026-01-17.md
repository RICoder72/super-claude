# Super Claude Code Audit Report
**Date:** 2026-01-17  
**Auditor:** Claude  
**Scope:** Full codebase review of Super Claude MCP infrastructure

---

## Executive Summary

Super Claude is a well-architected personal MCP infrastructure with good separation of concerns and a thoughtful plugin system. The codebase is functional and maintainable, but has accumulated some technical debt as features were added iteratively. Key areas for improvement include reducing code duplication, tightening security boundaries, and improving the modularity of the main server file.

**Overall Health:** ðŸŸ¢ Good (minor issues, no critical blockers)

---

## 1. Inefficiencies

### 1.1 Large Monolithic Server File (server.py - 36KB, ~1000 lines)

**Issue:** `mcps/super-claude/server.py` contains all tool definitions, helpers, and initialization in one file. This makes it harder to navigate, test, and maintain.

**Impact:** Medium - Slows development, increases cognitive load

**Recommendation:** Split into modules:
```
mcps/super-claude/
â”œâ”€â”€ server.py              # Entry point only (~50 lines)
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ session.py         # session_start, ping
â”‚   â”œâ”€â”€ filesystem.py      # fs_* tools
â”‚   â”œâ”€â”€ docker.py          # docker_* tools
â”‚   â”œâ”€â”€ context.py         # context_* tools
â”‚   â”œâ”€â”€ publish.py         # publish, unpublish, publish_list
â”‚   â”œâ”€â”€ storage.py         # storage_* tools
â”‚   â””â”€â”€ token.py           # token_status, token_record
â””â”€â”€ helpers/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ shell.py           # _run_command, _shell_exec_impl
    â””â”€â”€ domain.py          # _detect_domain, _get_domain_path, etc.
```

### 1.2 Synchronous Path Resolution in Google Drive

**Issue:** `gdrive.py::_resolve_path()` makes sequential API calls to resolve `/path/to/folder` one segment at a time. For deep paths, this causes N API round-trips.

**Impact:** Low-Medium - Slows operations on deep folder structures

**Recommendation:** 
- Cache resolved folder IDs in memory or on disk
- Consider using full path search query where supported

### 1.3 Plugin Tool Registration Indirection

**Issue:** Supernote plugin tools are defined twice:
1. In `plugins/supernote.py` as methods
2. In `server.py` as wrapper `@mcp.tool()` functions that call the plugin methods

This creates maintenance burden and potential for drift.

**Impact:** Low - Adds boilerplate, but works correctly

**Recommendation:** Create a plugin-to-MCP bridge that auto-registers plugin tools:
```python
def register_plugin_tools(mcp, plugin):
    for name, func in plugin.get_tools().items():
        mcp.tool()(func)  # Directly register
```

---

## 2. Repetition / Abstraction Opportunities

### 2.1 Duplicate `_run_command` / `_run` Helpers

**Issue:** Nearly identical shell execution code exists in:
- `server.py::_run_command()` 
- `server.py::_shell_exec_impl()`
- `mcps/ops/server.py::_run()`

All do the same thing with minor variations.

**Recommendation:** Extract to `shared/shell.py`:
```python
def run_shell(command: str, timeout: int = 30, cwd: Path = None) -> tuple[bool, str]:
    """Unified shell execution for all MCPs."""
    ...
```

### 2.2 Duplicate Path Constants

**Issue:** `SUPER_CLAUDE_ROOT = Path("/data")` is defined in:
- `server.py` (twice!)
- `mcps/ops/server.py`
- `plugins/supernote.py` (as `DOMAINS_ROOT`)

**Recommendation:** Create `shared/config.py`:
```python
from pathlib import Path

SUPER_CLAUDE_ROOT = Path("/data")
DOMAINS_DIR = SUPER_CLAUDE_ROOT / "domains"
CONFIG_DIR = SUPER_CLAUDE_ROOT / "config"
OUTPUTS_DIR = SUPER_CLAUDE_ROOT / "outputs"
DOCKER_NETWORK = "super-claude_super-claude-net"
PUBLIC_BASE_URL = "https://zanni.synology.me/super-claude-output"
```

### 2.3 Duplicate Docker Command Patterns

**Issue:** Docker run commands in both `server.py::rebuild_ops()` and `ops/server.py::rebuild_super_claude()` have similar patterns with hardcoded values.

**Recommendation:** Create a docker helpers module or config file with container specs.

### 2.4 Repeated JSON State File Handling

**Issue:** Pattern of "load JSON, modify, save" appears in:
- `context_update()`
- `token_record()`
- `supernote.py::_load_config()` / `_save_config()`

**Recommendation:** Create a `StateFile` utility class:
```python
class StateFile:
    def __init__(self, path: Path):
        self.path = path
    
    def load(self) -> dict: ...
    def save(self, data: dict): ...
    def update(self, key: str, value: Any): ...
```

---

## 3. Security Issues

### 3.1 âš ï¸ Docker Socket Mounted in super-claude Container

**Issue:** `super-claude` container has `-v /var/run/docker.sock:/var/run/docker.sock` which grants full Docker control. Combined with `shell_exec`, this allows:
- Starting/stopping any container on the host
- Creating privileged containers
- Accessing other Docker volumes

**Risk:** High - If Claude is manipulated (prompt injection), it could damage the host system.

**Current Mitigation:** Claude's safety guidelines prevent harmful actions, but this is a soft guard.

**Recommendation:**
1. **Short-term:** Add allowlist to `shell_exec` that blocks dangerous commands:
   ```python
   BLOCKED_PATTERNS = ['docker rm', 'docker rmi', 'docker stop', 'rm -rf /']
   ```
2. **Long-term:** Remove Docker socket from super-claude; only ops should have it.

### 3.2 âš ï¸ Auth Service Uses In-Memory Code Store

**Issue:** `auth-service/server.js` stores authorization codes in a JavaScript `Map()`:
```javascript
const authCodes = new Map();
```

This means:
- Codes lost on restart
- Potential memory leak if codes aren't cleaned up
- Single-instance only (can't scale horizontally)

**Risk:** Low (personal infrastructure, single user)

**Recommendation:** For future-proofing, add code expiry cleanup:
```javascript
// Clean up expired codes periodically
setInterval(() => {
    const now = Date.now();
    for (const [code, data] of authCodes) {
        if (now > data.expiresAt) authCodes.delete(code);
    }
}, 60000);
```

### 3.3 âš ï¸ Published Files Now Public (Intentional)

**Issue:** As of today's change, `/super-claude-output/*` files are publicly accessible without auth.

**Risk:** Low - URLs are unguessable, content is user-generated, infrastructure is personal.

**Mitigation:** Already on TODO - implement cookie-based auth for proper browser session support.

### 3.4 ðŸŸ¡ No Rate Limiting on Auth Endpoints

**Issue:** `/token` endpoint has no rate limiting, allowing brute-force attempts on client credentials.

**Risk:** Low (internal network, Synology firewall)

**Recommendation:** Add express-rate-limit:
```javascript
const rateLimit = require('express-rate-limit');
app.use('/token', rateLimit({ windowMs: 15*60*1000, max: 10 }));
```

### 3.5 ðŸŸ¢ Good: Path Validation in Filesystem Tools

**Positive:** `_validate_path()` properly prevents path traversal outside `/data`. This is well implemented.

---

## 4. Architectural Issues

### 4.1 Plugin System Can't Add MCP Tools Dynamically

**Issue:** Plugins define tools, but those tools aren't automatically registered with FastMCP. Currently requires manual wrapper functions in `server.py`:
```python
if 'supernote' in plugin_loader.loaded_plugins:
    @mcp.tool()
    async def supernote_setup(...):
        return await _supernote.supernote_setup(...)
```

**Impact:** Medium - Every new plugin tool requires server.py modification.

**Root Cause:** FastMCP's `@mcp.tool()` decorator runs at import time, before plugins are loaded.

**Recommendation:** Two options:
1. **Lazy registration:** Use FastMCP's programmatic tool registration (if available)
2. **Code generation:** Plugin loader generates wrapper code and reloads server
3. **Accept it:** Document this as a known limitation for personal use

### 4.2 Storage Manager Async/Sync Mismatch

**Issue:** `StorageManager` methods are `async`, but `_load_accounts()` and `_save_accounts()` are sync. Mixing paradigms can cause subtle issues.

**Recommendation:** Make all methods async or all sync. Since file I/O is fast and local, sync is fine here.

### 4.3 Supernote Plugin Reaches Into server.py

**Issue:** `supernote.py` imports `server` module to access `storage_manager`:
```python
def _get_storage_manager(self):
    import server
    return server.storage_manager
```

This creates a circular dependency risk and tight coupling.

**Recommendation:** Pass `storage_manager` to plugin during initialization:
```python
class SupernotePlugin(SuperClaudePlugin):
    def initialize(self, storage_manager=None):
        self.storage_manager = storage_manager
```

### 4.4 No Health Checks for Plugin Dependencies

**Issue:** If `supernotelib` (for conversion) isn't installed, the plugin loads but `_convert_note()` will fail at runtime.

**Recommendation:** Add dependency checking to plugin `initialize()`:
```python
def initialize(self):
    # Check dependencies
    try:
        subprocess.run(['supernote-tool', '--version'], check=True, capture_output=True)
    except FileNotFoundError:
        logger.warning("supernote-tool not installed, conversion disabled")
        self.conversion_available = False
```

### 4.5 Missing Error Handling in Token Check

**Issue:** `_check_token_expiry()` catches all exceptions and returns `None`, silently hiding errors:
```python
except Exception:
    return None
```

**Recommendation:** Log the exception for debugging:
```python
except Exception as e:
    logger.debug(f"Token expiry check failed: {e}")
    return None
```

---

## 5. Code Quality Issues

### 5.1 Inconsistent Return Types

**Issue:** Some functions return strings, some return tuples, some return objects:
- `_run_command()` â†’ `tuple[bool, str]`
- `_shell_exec_impl()` â†’ `str`
- Storage tools â†’ `str` or `List[FileInfo]`

**Recommendation:** Standardize on result objects or consistent patterns.

### 5.2 Missing Type Hints in Several Places

**Issue:** Some functions lack type hints, making IDE support weaker:
```python
def _get_domain_path(domain: str) -> Path:  # âœ… Good
def _load_domain_config() -> dict:           # ðŸŸ¡ Should be Dict[str, Any]
```

### 5.3 Duplicate SUPER_CLAUDE_ROOT Definition

**Issue:** `server.py` defines `SUPER_CLAUDE_ROOT` twice (lines ~20 and ~80).

**Recommendation:** Remove the duplicate.

---

## 6. Recommendations Summary

### Priority 1 (Do Soon)
1. Add command blocklist to `shell_exec` for safety
2. Remove duplicate `SUPER_CLAUDE_ROOT` definition
3. Extract shared constants to `shared/config.py`

### Priority 2 (Next Refactor)
1. Split `server.py` into modules
2. Unify shell execution helpers
3. Fix supernote plugin â†’ storage_manager coupling

### Priority 3 (Future)
1. Auto-register plugin tools with MCP
2. Add rate limiting to auth service
3. Implement cookie-based auth for published files

---

## 7. What's Working Well

- **Clean plugin architecture** - Easy to add new plugins
- **Storage abstraction** - Provider-agnostic design is solid  
- **Domain system** - Contextual loading works smoothly
- **Auth implementation** - OAuth + JWT is properly implemented
- **Path sandboxing** - Filesystem tools are properly restricted
- **Documentation** - Good inline comments and changelog discipline
- **Separation of concerns** - ops vs main MCP split is smart

---

*Report generated by Claude during code audit session*
